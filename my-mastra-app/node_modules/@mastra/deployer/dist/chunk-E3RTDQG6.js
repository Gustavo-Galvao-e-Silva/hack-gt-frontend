import { DepsService } from './chunk-CHKSDG3W.js';
import * as babel from '@babel/core';
import babel__default from '@babel/core';
import fs, { existsSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import * as path2 from 'path';
import path2__default, { dirname, join, normalize } from 'path';
import { spawn as spawn$1 } from 'child_process';
import { rollup } from 'rollup';
import originalEsbuild from 'rollup-plugin-esbuild';
import commonjs from '@rollup/plugin-commonjs';
import resolveFrom2 from 'resolve-from';
import { createHandler } from 'typescript-paths';
import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';
import json from '@rollup/plugin-json';
import slugify from '@sindresorhus/slugify';
import * as pkg from 'empathic/package';
import { createWorkspacesCache, findWorkspaces, findWorkspacesRoot } from 'find-workspaces';
import { ensureDir } from 'fs-extra';
import { noopLogger } from '@mastra/core/logger';
import virtual from '@rollup/plugin-virtual';
import { fileURLToPath } from 'url';
import { builtinModules } from 'module';
import { getPackageInfo } from 'local-pkg';
import nodeResolve from '@rollup/plugin-node-resolve';
import esmShim from '@rollup/plugin-esm-shim';
import { basename } from 'path/posix';

function spawn(command, args = [], options = {}) {
  return new Promise((resolve, reject) => {
    const childProcess = spawn$1(command, args, {
      // stdio: 'inherit',
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    let stderr = "";
    childProcess.stderr?.on("data", (message) => {
      stderr += message;
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(stderr));
      }
    });
  });
}
function validate(file) {
  return spawn(
    "node",
    [
      "--import",
      import.meta.resolve("@mastra/deployer/loader"),
      "--input-type=module",
      "-e",
      `import('file://${file.replaceAll("\\", "/")}')`
    ],
    {
      cwd: dirname(file)
    }
  );
}
function removeAllOptionsFromMastraExcept(result, option, logger) {
  const t = babel__default.types;
  return {
    name: "remove-all-except-" + option + "-config",
    visitor: {
      ExportNamedDeclaration: {
        // remove all exports
        exit(path3) {
          path3.remove();
        }
      },
      NewExpression(path3, state) {
        const varDeclaratorPath = path3.findParent((path4) => t.isVariableDeclarator(path4.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path3.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        let mastraArgs = t.objectExpression([]);
        if (t.isObjectExpression(path3.node.arguments[0])) {
          mastraArgs = path3.node.arguments[0];
        }
        let telemetry = mastraArgs.properties.find(
          // @ts-ignore
          (prop) => prop.key.name === option
        );
        let telemetryValue = t.objectExpression([]);
        const programPath = path3.scope.getProgramParent().path;
        if (!programPath) {
          return;
        }
        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {
          result.hasCustomConfig = true;
          telemetryValue = telemetry.value;
          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {
            const telemetryBinding = state.file.scope.getBinding(option);
            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {
              const id = path3.scope.generateUidIdentifier(option);
              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init));
              telemetryValue = id;
            }
          }
        }
        const exportDeclaration = t.exportNamedDeclaration(
          t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), telemetryValue)]),
          []
        );
        programPath.node.body.push(exportDeclaration);
      },
      Program: {
        exit(path3) {
          const hasExport = path3.node.body.some(
            (node) => node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration"
          );
          if (!hasExport) {
            if (logger) {
              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:
export const mastra = new Mastra({
  ${option}: <value>
})

`);
            }
            const fallbackExportDeclaration = t.exportNamedDeclaration(
              t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),
              []
            );
            path3.node.body.push(fallbackExportDeclaration);
          }
        }
      }
    }
  };
}

// src/build/babel/remove-all-options-bundler.ts
function removeAllOptionsExceptBundler(result, logger) {
  return removeAllOptionsFromMastraExcept(result, "bundler", logger);
}
function esbuild(options = {}) {
  return originalEsbuild({
    target: "node20",
    platform: "node",
    minify: false,
    ...options
  });
}
var PLUGIN_NAME = "tsconfig-paths";
function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve } = {}) {
  let handler;
  return {
    name: PLUGIN_NAME,
    buildStart() {
      handler = createHandler({
        log: () => {
        },
        tsConfigPath,
        respectCoreModule,
        falllback: (moduleName) => fs.existsSync(moduleName)
      });
      return;
    },
    async resolveId(request, importer, options) {
      if (!importer || request.startsWith("\0")) {
        return null;
      }
      const moduleName = handler?.(request, normalize(importer));
      if (!moduleName) {
        let importerMeta = {};
        const resolved = await this.resolve(request, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        if (localResolve) {
          const importerInfo = this.getModuleInfo(importer);
          importerMeta = importerInfo?.meta || {};
          if (!request.startsWith("./") && !request.startsWith("../") && importerMeta?.[PLUGIN_NAME]?.resolved) {
            return {
              ...resolved,
              external: !request.startsWith("hono/") && request !== "hono"
            };
          }
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta || {},
            ...importerMeta
          }
        };
      }
      if (!path2__default.extname(moduleName)) {
        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta,
            [PLUGIN_NAME]: {
              resolved: true
            }
          }
        };
      }
      return {
        id: moduleName,
        meta: {
          [PLUGIN_NAME]: {
            resolved: true
          }
        }
      };
    }
  };
}
function removeNonReferencedNodes() {
  const t = babel__default.types;
  return {
    name: "remove-non-referenced-nodes",
    visitor: {
      Program(path3) {
        const scope = path3.scope;
        const currentBody = path3.get("body");
        const filteredBody = currentBody.filter((childPath) => {
          if (childPath.isExportDeclaration()) {
            return true;
          }
          if (childPath.isVariableDeclaration()) {
            return childPath.node.declarations.some((decl) => {
              if (!t.isIdentifier(decl.id)) {
                return false;
              }
              const name = decl.id.name;
              const binding = scope.getBinding(name);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {
            if (!t.isIdentifier(childPath.node.id)) {
              return false;
            }
            const name = childPath.node.id.name;
            const binding = scope.getBinding(name);
            return binding && (binding.referenced || binding.referencePaths.length > 0);
          }
          if (childPath.isImportDeclaration()) {
            return childPath.node.specifiers.some((specifier) => {
              const importedName = specifier.local.name;
              const binding = scope.getBinding(importedName);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          return false;
        });
        path3.set(
          "body",
          filteredBody.map((p) => p.node)
        );
      }
    }
  };
}

// src/build/plugins/remove-unused-references.ts
function recursiveRemoveNonReferencedNodes(code) {
  return new Promise(async (resolve, reject) => {
    babel.transform(
      code,
      {
        babelrc: false,
        configFile: false,
        plugins: [removeNonReferencedNodes()]
      },
      (err, result) => {
        if (err) {
          return reject(err);
        }
        if (result && result.code !== code) {
          return recursiveRemoveNonReferencedNodes(result.code).then(resolve, reject);
        }
        resolve({
          code: result.code,
          map: result.map
        });
      }
    );
  });
}
function extractMastraOptionBundler(name, entryFile, transformer, result, logger) {
  return rollup({
    logLevel: "silent",
    input: {
      [`${name}-config`]: entryFile
    },
    treeshake: "smallest",
    plugins: [
      tsConfigPaths(),
      // transpile typescript to something we understand
      esbuild(),
      optimizeLodashImports(),
      commonjs({
        extensions: [".js", ".ts"],
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      json(),
      {
        name: `extract-${name}-config`,
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return new Promise((resolve, reject) => {
            babel.transform(
              code,
              {
                babelrc: false,
                configFile: false,
                filename: id,
                plugins: [transformer(result, logger)]
              },
              (err, result2) => {
                if (err) {
                  return reject(err);
                }
                resolve({
                  code: result2.code,
                  map: result2.map
                });
              }
            );
          });
        }
      },
      // let esbuild remove all unused imports
      esbuild(),
      {
        name: "cleanup",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return recursiveRemoveNonReferencedNodes(code);
        }
      },
      // let esbuild remove it once more
      esbuild()
    ]
  });
}
async function extractMastraOption(name, entryFile, transformer, outputDir, logger) {
  const result = {
    hasCustomConfig: false
  };
  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);
  const output = await bundler.write({
    dir: outputDir,
    format: "es",
    entryFileNames: "[name].mjs"
  });
  if (result.hasCustomConfig) {
    const configPath = `${outputDir}/${name}-config.mjs`;
    return {
      bundleOutput: output,
      getConfig: () => import(`file:${configPath}`).then((m) => m[name])
    };
  }
  return null;
}

// src/build/bundlerOptions.ts
async function getBundlerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption(
    "bundler",
    entryFile,
    removeAllOptionsExceptBundler,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}
function checkConfigExport(result) {
  const t = babel__default.types;
  const mastraVars = /* @__PURE__ */ new Set();
  return {
    visitor: {
      ExportNamedDeclaration(path3) {
        const decl = path3.node.declaration;
        if (t.isVariableDeclaration(decl)) {
          const varDecl = decl.declarations[0];
          if (t.isIdentifier(varDecl?.id, { name: "mastra" }) && t.isNewExpression(varDecl.init) && t.isIdentifier(varDecl.init.callee, { name: "Mastra" })) {
            result.hasValidConfig = true;
          }
        }
        if (Array.isArray(path3.node.specifiers)) {
          for (const spec of path3.node.specifiers) {
            if (t.isExportSpecifier(spec) && t.isIdentifier(spec.exported, { name: "mastra" }) && t.isIdentifier(spec.local) && mastraVars.has(spec.local.name)) {
              result.hasValidConfig = true;
            }
          }
        }
      },
      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`
      VariableDeclaration(path3) {
        for (const decl of path3.node.declarations) {
          if (t.isIdentifier(decl.id) && t.isNewExpression(decl.init) && t.isIdentifier(decl.init.callee, { name: "Mastra" })) {
            mastraVars.add(decl.id.name);
          }
        }
      }
    }
  };
}
var workspacesCache = createWorkspacesCache();
async function getWorkspaceInformation({
  dir = process.cwd(),
  mastraEntryFile
}) {
  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });
  const location = closestPkgJson ? dirname(closestPkgJson) : process.cwd();
  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });
  const _workspaceMap = new Map(
    workspaces?.map((workspace) => [
      workspace.package.name,
      {
        location: workspace.location,
        dependencies: workspace.package.dependencies,
        version: workspace.package.version
      }
    ]) ?? []
  );
  const isWorkspacePackage = (workspaces ?? []).some((ws) => ws.location === location);
  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : void 0;
  return {
    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages
    workspaceMap: isWorkspacePackage ? _workspaceMap : /* @__PURE__ */ new Map(),
    workspaceRoot,
    isWorkspacePackage
  };
}
var collectTransitiveWorkspaceDependencies = ({
  workspaceMap,
  initialDependencies,
  logger
}) => {
  const usedWorkspacePackages = /* @__PURE__ */ new Set();
  const queue = Array.from(initialDependencies);
  const resolutions = {};
  while (queue.length > 0) {
    const len = queue.length;
    for (let i = 0; i < len; i += 1) {
      const pkgName = queue.shift();
      if (!pkgName || usedWorkspacePackages.has(pkgName)) {
        continue;
      }
      const dep = workspaceMap.get(pkgName);
      if (!dep) continue;
      const root = findWorkspacesRoot();
      if (!root) {
        throw new Error("Could not find workspace root");
      }
      const depsService = new DepsService(root.location);
      depsService.__setLogger(logger);
      const sanitizedName = slugify(pkgName);
      const tgzPath = depsService.getWorkspaceDependencyPath({
        pkgName: sanitizedName,
        version: dep.version
      });
      resolutions[pkgName] = tgzPath;
      usedWorkspacePackages.add(pkgName);
      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {
        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {
          queue.push(depName);
        }
      }
    }
  }
  return { resolutions, usedWorkspacePackages };
};
var packWorkspaceDependencies = async ({
  workspaceMap,
  usedWorkspacePackages,
  bundleOutputDir,
  logger
}) => {
  const root = findWorkspacesRoot();
  if (!root) {
    throw new Error("Could not find workspace root");
  }
  const depsService = new DepsService(root.location);
  depsService.__setLogger(logger);
  if (usedWorkspacePackages.size > 0) {
    const workspaceDirPath = join(bundleOutputDir, "workspace-module");
    await ensureDir(workspaceDirPath);
    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);
    const batchSize = 5;
    const packages = Array.from(usedWorkspacePackages.values());
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      logger.info(
        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(", ")}`
      );
      await Promise.all(
        batch.map(async (pkgName) => {
          const dep = workspaceMap.get(pkgName);
          const sanitizedName = slugify(pkgName);
          if (!dep) return;
          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName });
        })
      );
    }
    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);
  }
};
function isNodeBuiltin(dep) {
  const [pkg2] = dep.split("/");
  return dep.startsWith("node:") || builtinModules.includes(dep) || builtinModules.includes(pkg2);
}
function removeDeployer() {
  const t = babel__default.types;
  return {
    name: "remove-deployer",
    visitor: {
      NewExpression(path3, state) {
        const varDeclaratorPath = path3.findParent((path4) => t.isVariableDeclarator(path4.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path3.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        if (!state.hasReplaced) {
          state.hasReplaced = true;
          const newMastraObj = t.cloneNode(path3.node);
          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {
            const deployer = newMastraObj.arguments[0].properties.find(
              (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "deployer"
            );
            if (!deployer) {
              return;
            }
            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(
              (prop) => prop !== deployer
            );
            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {
              const deployerBinding = state.file.scope.getBinding(deployer.value.name);
              if (deployerBinding) {
                deployerBinding?.path?.parentPath?.remove();
              }
            }
            path3.replaceWith(newMastraObj);
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-deployer.ts
function removeDeployer2(mastraEntry, options) {
  return {
    name: "remove-deployer",
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve, reject) => {
        babel.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeDeployer],
            sourceMaps: options?.sourcemap
          },
          (err, result) => {
            if (err) {
              return reject(err);
            }
            resolve({
              code: result.code,
              map: result.map
            });
          }
        );
      });
    }
  };
}
function getPackageName(id) {
  const parts = id.split("/");
  if (id.startsWith("@")) {
    return parts.slice(0, 2).join("/");
  }
  return parts[0];
}
async function getPackageRootPath(packageName) {
  let rootPath;
  try {
    const pkg2 = await getPackageInfo(packageName);
    rootPath = pkg2?.rootPath ?? null;
  } catch (e) {
    rootPath = null;
  }
  return rootPath;
}
function getCompiledDepCachePath(rootPath, packageName) {
  return join(rootPath, "node_modules", ".cache", packageName);
}

// src/build/analyze/constants.ts
var DEPS_TO_IGNORE = ["#tools"];
var GLOBAL_EXTERNALS = ["pino", "pino-pretty", "@libsql/client", "pg", "libsql", "#tools"];
var DEPRECATED_EXTERNALS = ["fastembed", "nodemailer", "jsdom", "sqlite3"];

// src/build/analyze/analyzeEntry.ts
function getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }) {
  const normalizedMastraEntry = mastraEntry.replaceAll("\\", "/");
  let virtualPlugin = null;
  if (isVirtualFile) {
    virtualPlugin = virtual({
      "#entry": entry
    });
    entry = "#entry";
  }
  const plugins = [];
  if (virtualPlugin) {
    plugins.push(virtualPlugin);
  }
  plugins.push(
    ...[
      tsConfigPaths(),
      {
        name: "custom-alias-resolver",
        resolveId(id) {
          if (id === "#server") {
            return fileURLToPath(import.meta.resolve("@mastra/deployer/server")).replaceAll("\\", "/");
          }
          if (id === "#mastra") {
            return normalizedMastraEntry;
          }
          if (id.startsWith("@mastra/server")) {
            return fileURLToPath(import.meta.resolve(id));
          }
        }
      },
      json(),
      esbuild(),
      commonjs({
        strictRequires: "debug",
        ignoreTryCatch: false,
        transformMixedEsModules: true,
        extensions: [".js", ".ts"]
      }),
      removeDeployer2(mastraEntry, { sourcemap: sourcemapEnabled }),
      esbuild()
    ]
  );
  return plugins;
}
async function captureDependenciesToOptimize(output, workspaceMap, projectRoot, {
  logger
}) {
  const depsToOptimize = /* @__PURE__ */ new Map();
  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {
    if (isNodeBuiltin(dependency) || DEPS_TO_IGNORE.includes(dependency)) {
      continue;
    }
    const pkgName = getPackageName(dependency);
    let rootPath = null;
    let isWorkspace = false;
    if (pkgName) {
      rootPath = await getPackageRootPath(pkgName);
      isWorkspace = workspaceMap.has(pkgName);
    }
    depsToOptimize.set(dependency, { exports: bindings, rootPath, isWorkspace });
  }
  async function checkTransitiveDependencies(internalMap, maxDepth = 10, currentDepth = 0) {
    if (currentDepth >= maxDepth) {
      logger.warn("Maximum dependency depth reached while checking transitive dependencies.");
      return;
    }
    const depsSnapshot = new Map(depsToOptimize);
    let hasAddedDeps = false;
    for (const [dep, meta] of depsSnapshot) {
      if (!meta.isWorkspace || internalMap.has(dep)) {
        continue;
      }
      try {
        const resolvedPath = resolveFrom2(projectRoot, dep);
        if (!resolvedPath) {
          logger.warn(`Could not resolve path for workspace dependency ${dep}`);
          continue;
        }
        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, "", {
          workspaceMap,
          projectRoot,
          logger: noopLogger,
          sourcemapEnabled: false
        });
        if (!analysis?.dependencies) {
          continue;
        }
        for (const [innerDep, innerMeta] of analysis.dependencies) {
          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {
            depsToOptimize.set(innerDep, innerMeta);
            internalMap.set(innerDep, innerMeta);
            hasAddedDeps = true;
          }
        }
      } catch (err) {
        logger.error(`Failed to resolve or analyze dependency ${dep}: ${err.message}`);
      }
    }
    if (hasAddedDeps) {
      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);
    }
  }
  await checkTransitiveDependencies(/* @__PURE__ */ new Map());
  const dynamicImports = output.dynamicImports.filter((d) => !DEPS_TO_IGNORE.includes(d));
  if (dynamicImports.length) {
    for (const dynamicImport of dynamicImports) {
      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {
        depsToOptimize.set(dynamicImport, { exports: ["*"], rootPath: null, isWorkspace: false });
      }
    }
  }
  return depsToOptimize;
}
async function analyzeEntry({
  entry,
  isVirtualFile
}, mastraEntry, {
  logger,
  sourcemapEnabled,
  workspaceMap,
  projectRoot
}) {
  const optimizerBundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: isVirtualFile ? "#entry" : entry,
    treeshake: "smallest",
    preserveSymlinks: true,
    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),
    external: DEPS_TO_IGNORE
  });
  const { output } = await optimizerBundler.generate({
    format: "esm",
    inlineDynamicImports: true
  });
  await optimizerBundler.close();
  const depsToOptimize = await captureDependenciesToOptimize(output[0], workspaceMap, projectRoot, {
    logger
  });
  return {
    dependencies: depsToOptimize,
    output: {
      code: output[0].code,
      map: output[0].map
    }
  };
}
function aliasHono() {
  return {
    name: "hono-alias",
    resolveId(id) {
      if (!id.startsWith("@hono/") && !id.startsWith("hono/") && id !== "hono" && id !== "hono-openapi") {
        return;
      }
      const path3 = import.meta.resolve(id);
      return fileURLToPath(path3);
    }
  };
}

// src/build/analyze/bundleExternals.ts
function prepareEntryFileName(name, rootDir) {
  const relativePath = path2.relative(rootDir, name);
  return relativePath.replaceAll(path2.sep, path2.posix.sep);
}
function createVirtualDependencies(depsToOptimize, { projectRoot, workspaceRoot, outputDir }) {
  const fileNameToDependencyMap = /* @__PURE__ */ new Map();
  const optimizedDependencyEntries = /* @__PURE__ */ new Map();
  const rootDir = workspaceRoot || projectRoot;
  for (const [dep, { exports }] of depsToOptimize.entries()) {
    const fileName = dep.replaceAll("/", "-");
    const virtualFile = [];
    const exportStringBuilder = [];
    for (const local of exports) {
      if (local === "*") {
        virtualFile.push(`export * from '${dep}';`);
        continue;
      } else if (local === "default") {
        exportStringBuilder.push("default");
      } else {
        exportStringBuilder.push(local);
      }
    }
    const chunks = [];
    if (exportStringBuilder.length) {
      chunks.push(`{ ${exportStringBuilder.join(", ")} }`);
    }
    if (chunks.length) {
      virtualFile.push(`export ${chunks.join(", ")} from '${dep}';`);
    }
    let entryName = prepareEntryFileName(path2.join(outputDir, fileName), rootDir);
    fileNameToDependencyMap.set(entryName, dep);
    optimizedDependencyEntries.set(dep, {
      name: entryName,
      virtual: virtualFile.join("\n")
    });
  }
  for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {
    if (!isWorkspace || !rootPath || !workspaceRoot) {
      continue;
    }
    const currentDepPath = optimizedDependencyEntries.get(dep);
    if (!currentDepPath) {
      continue;
    }
    const fileName = basename(currentDepPath.name);
    const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);
    fileNameToDependencyMap.set(entryName, dep);
    optimizedDependencyEntries.set(dep, {
      ...currentDepPath,
      name: entryName
    });
  }
  return { optimizedDependencyEntries, fileNameToDependencyMap };
}
async function getInputPlugins2(virtualDependencies, transpilePackages, workspaceMap, bundlerOptions) {
  const transpilePackagesMap = /* @__PURE__ */ new Map();
  for (const pkg2 of transpilePackages) {
    const dir = await getPackageRootPath(pkg2);
    if (dir) {
      transpilePackagesMap.set(pkg2, dir);
    }
  }
  return [
    virtual(
      Array.from(virtualDependencies.entries()).reduce(
        (acc, [dep, virtualDep]) => {
          acc[`#virtual-${dep}`] = virtualDep.virtual;
          return acc;
        },
        {}
      )
    ),
    transpilePackagesMap.size ? esbuild({
      format: "esm",
      include: [...transpilePackagesMap.values()].map((p) => {
        return new RegExp(`^${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
      })
    }) : null,
    commonjs({
      strictRequires: "strict",
      transformMixedEsModules: true,
      ignoreTryCatch: false
    }),
    bundlerOptions.enableEsmShim ? esmShim() : void 0,
    nodeResolve({
      preferBuiltins: true,
      exportConditions: ["node"],
      // Do not embed external dependencies into files that we write to `node_modules/.cache` (for the mastra dev + workspace use case)
      ...workspaceMap.size > 0 ? { resolveOnly: Array.from(workspaceMap.keys()) } : {}
    }),
    // hono is imported from deployer, so we need to resolve from here instead of the project root
    aliasHono(),
    json()
  ];
}
async function buildExternalDependencies(virtualDependencies, {
  externals,
  packagesToTranspile,
  workspaceMap,
  rootDir,
  outputDir,
  bundlerOptions
}) {
  if (virtualDependencies.size === 0) {
    return [];
  }
  const bundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: Array.from(virtualDependencies.entries()).reduce(
      (acc, [dep, virtualDep]) => {
        acc[virtualDep.name] = `#virtual-${dep}`;
        return acc;
      },
      {}
    ),
    external: externals,
    treeshake: "smallest",
    plugins: getInputPlugins2(virtualDependencies, packagesToTranspile, workspaceMap, bundlerOptions)
  });
  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);
  const { output } = await bundler.write({
    format: "esm",
    dir: rootDir,
    entryFileNames: "[name].mjs",
    /**
     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.
     * So we want to write them to the `.mastra/output` folder as well.
     */
    chunkFileNames: `${outputDirRelative}/[name].mjs`,
    hoistTransitiveImports: false
  });
  await bundler.close();
  return output;
}
function findExternalImporter(module, external, allOutputs) {
  const capturedFiles = /* @__PURE__ */ new Set();
  for (const id of module.imports) {
    if (id === external) {
      return module;
    } else {
      if (id.endsWith(".mjs")) {
        capturedFiles.add(id);
      }
    }
  }
  for (const file of capturedFiles) {
    const nextModule = allOutputs.find((o) => o.fileName === file);
    if (nextModule) {
      const importer = findExternalImporter(nextModule, external, allOutputs);
      if (importer) {
        return importer;
      }
    }
  }
  return null;
}
async function bundleExternals(depsToOptimize, outputDir, options) {
  const { workspaceRoot = null, workspaceMap = /* @__PURE__ */ new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;
  const {
    externals: customExternals = [],
    transpilePackages = [],
    isDev = false,
    enableEsmShim = true
  } = bundlerOptions || {};
  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...customExternals];
  const workspacePackagesNames = Array.from(workspaceMap.keys());
  const packagesToTranspile = /* @__PURE__ */ new Set([...transpilePackages, ...workspacePackagesNames]);
  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {
    workspaceRoot,
    outputDir,
    projectRoot
  });
  const output = await buildExternalDependencies(optimizedDependencyEntries, {
    externals: allExternals,
    packagesToTranspile,
    workspaceMap: isDev ? workspaceMap : /* @__PURE__ */ new Map(),
    rootDir: workspaceRoot || projectRoot,
    outputDir,
    bundlerOptions: {
      enableEsmShim
    }
  });
  const moduleResolveMap = /* @__PURE__ */ new Map();
  const filteredChunks = output.filter((o) => o.type === "chunk");
  for (const o of filteredChunks.filter((o2) => o2.isEntry || o2.isDynamicEntry)) {
    for (const external of allExternals) {
      if (DEPS_TO_IGNORE.includes(external)) {
        continue;
      }
      const importer = findExternalImporter(o, external, filteredChunks);
      if (importer) {
        const fullPath = path2.join(workspaceRoot || projectRoot, importer.fileName);
        let innerMap = moduleResolveMap.get(fullPath);
        if (!innerMap) {
          innerMap = /* @__PURE__ */ new Map();
          moduleResolveMap.set(fullPath, innerMap);
        }
        if (importer.moduleIds.length) {
          innerMap.set(
            external,
            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith("\0virtual:#virtual") ? importer.moduleIds[importer.moduleIds.length - 2] : importer.moduleIds[importer.moduleIds.length - 1]
          );
        }
      }
    }
  }
  const usedExternals = /* @__PURE__ */ Object.create(null);
  for (const [fullPath, innerMap] of moduleResolveMap) {
    const innerObj = /* @__PURE__ */ Object.create(null);
    for (const [external, value] of innerMap) {
      innerObj[external] = value;
    }
    usedExternals[fullPath] = innerObj;
  }
  return { output, fileNameToDependencyMap, usedExternals };
}

// src/build/analyze.ts
async function validateOutput({
  output,
  reverseVirtualReferenceMap,
  usedExternals,
  outputDir,
  projectRoot,
  workspaceMap
}, logger) {
  const result = {
    invalidChunks: /* @__PURE__ */ new Set(),
    dependencies: /* @__PURE__ */ new Map(),
    externalDependencies: /* @__PURE__ */ new Set(),
    workspaceMap
  };
  await writeFile(join(outputDir, "module-resolve-map.json"), JSON.stringify(usedExternals, null, 2));
  for (const deps of Object.values(usedExternals)) {
    for (const dep of Object.keys(deps)) {
      result.externalDependencies.add(dep);
    }
  }
  for (const file of output) {
    if (file.type === "asset") {
      continue;
    }
    try {
      logger.debug(`Validating if ${file.fileName} is a valid module.`);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        result.dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
      }
      if (!file.isDynamicEntry && file.isEntry) {
        await validate(join(projectRoot, file.fileName));
      }
    } catch (err) {
      result.invalidChunks.add(file.fileName);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        const reference = reverseVirtualReferenceMap.get(file.name);
        const dep = reference.startsWith("@") ? reference.split("/").slice(0, 2).join("/") : reference.split("/")[0];
        result.externalDependencies.add(dep);
      }
    }
  }
  return result;
}
async function analyzeBundle(entries, mastraEntry, {
  outputDir,
  projectRoot,
  isDev = false,
  bundlerOptions: _bundlerOptions
}, logger) {
  const mastraConfig = await readFile(mastraEntry, "utf-8");
  const mastraConfigResult = {
    hasValidConfig: false
  };
  await babel.transformAsync(mastraConfig, {
    filename: mastraEntry,
    presets: [import.meta.resolve("@babel/preset-typescript")],
    plugins: [checkConfigExport(mastraConfigResult)]
  });
  if (!mastraConfigResult.hasValidConfig) {
    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:
export const mastra = new Mastra({
  // your options
})
  
If you think your configuration is valid, please open an issue.`);
  }
  const { enableEsmShim = true } = _bundlerOptions || {};
  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);
  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });
  let index = 0;
  const depsToOptimize = /* @__PURE__ */ new Map();
  logger.info("Analyzing dependencies...");
  for (const entry of entries) {
    const isVirtualFile = entry.includes("\n") || !existsSync(entry);
    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {
      logger,
      sourcemapEnabled: bundlerOptions?.sourcemap ?? false,
      workspaceMap,
      projectRoot
    });
    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);
    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {
      if (depsToOptimize.has(dep)) {
        const existingEntry = depsToOptimize.get(dep);
        depsToOptimize.set(dep, {
          ...existingEntry,
          exports: [.../* @__PURE__ */ new Set([...existingEntry.exports, ...metadata.exports])]
        });
      } else {
        depsToOptimize.set(dep, metadata);
      }
    }
  }
  if (isDev) {
    for (const [dep, metadata] of depsToOptimize.entries()) {
      if (!metadata.isWorkspace) {
        depsToOptimize.delete(dep);
      }
    }
  }
  logger.debug(`Analyzed dependencies: ${Array.from(depsToOptimize.keys()).join(", ")}`);
  logger.info("Optimizing dependencies...");
  logger.debug(
    `${Array.from(depsToOptimize.keys()).map((key) => `- ${key}`).join("\n")}`
  );
  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {
    bundlerOptions: {
      ...bundlerOptions,
      enableEsmShim,
      isDev
    },
    projectRoot,
    workspaceRoot,
    workspaceMap
  });
  const result = await validateOutput(
    {
      output,
      reverseVirtualReferenceMap: fileNameToDependencyMap,
      usedExternals,
      outputDir,
      projectRoot: workspaceRoot || projectRoot,
      workspaceMap
    },
    logger
  );
  return result;
}

export { aliasHono, analyzeBundle, collectTransitiveWorkspaceDependencies, esbuild, extractMastraOption, getBundlerOptions, getPackageName, getPackageRootPath, getWorkspaceInformation, packWorkspaceDependencies, removeAllOptionsFromMastraExcept, removeDeployer2 as removeDeployer, tsConfigPaths };
//# sourceMappingURL=chunk-E3RTDQG6.js.map
//# sourceMappingURL=chunk-E3RTDQG6.js.map