'use strict';

var chunkBZDTNUHJ_cjs = require('./chunk-BZDTNUHJ.cjs');
var chunk36EU6KMX_cjs = require('./chunk-36EU6KMX.cjs');
var rollup = require('rollup');
var path = require('path');
var pkg = require('empathic/package');
var resolveFrom = require('resolve-from');
var module$1 = require('module');
var logger = require('@mastra/core/logger');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefault(path);
var pkg__namespace = /*#__PURE__*/_interopNamespace(pkg);
var resolveFrom__default = /*#__PURE__*/_interopDefault(resolveFrom);

function isBuiltinModule(specifier) {
  return module$1.builtinModules.includes(specifier) || specifier.startsWith("node:") || module$1.builtinModules.includes(specifier.replace(/^node:/, ""));
}
function safeResolve(id, importer) {
  try {
    return resolveFrom__default.default(importer, id);
  } catch {
    return null;
  }
}
function nodeModulesExtensionResolver() {
  return {
    name: "node-modules-extension-resolver",
    resolveId(id, importer) {
      if (id.startsWith(".") || id.startsWith("/") || !importer) {
        return null;
      }
      if (isBuiltinModule(id)) {
        return null;
      }
      if (id.startsWith("@") && id.split("/").length === 2) {
        return null;
      }
      if (!id.startsWith("@") && id.split("/").length === 1) {
        return null;
      }
      const foundExt = path.extname(id);
      if (foundExt) {
        return null;
      }
      try {
        const resolved = undefined(id);
        if (!path.extname(resolved)) {
          throw new Error(`Cannot resolve ${id} from ${importer}`);
        }
        return null;
      } catch (e) {
        const resolved = safeResolve(id, importer);
        if (resolved) {
          return {
            id: resolved,
            external: true
          };
        }
        for (const ext of [".mjs", ".js", ".cjs"]) {
          const resolved2 = safeResolve(id + ext, importer);
          if (resolved2) {
            const pkgName = chunk36EU6KMX_cjs.getPackageName(id);
            if (!pkgName) {
              return null;
            }
            const pkgJsonPath = safeResolve(`${pkgName}/package.json`, importer);
            if (!pkgJsonPath) {
              return null;
            }
            const newImportWithExtension = resolved2.replace(path.dirname(pkgJsonPath), pkgName);
            return {
              id: newImportWithExtension,
              external: true
            };
          }
        }
      }
      return null;
    }
  };
}
async function getInputOptions2(entryFile, platform, env, { sourcemap = false } = {}) {
  const closestPkgJson = pkg__namespace.up({ cwd: path.dirname(entryFile) });
  const projectRoot = closestPkgJson ? path.dirname(closestPkgJson) : process.cwd();
  const { workspaceMap, workspaceRoot } = await chunk36EU6KMX_cjs.getWorkspaceInformation({ mastraEntryFile: entryFile });
  const analyzeEntryResult = await chunk36EU6KMX_cjs.analyzeBundle(
    [entryFile],
    entryFile,
    {
      outputDir: path__default.default.join(process.cwd(), ".mastra/.build"),
      projectRoot: workspaceRoot || process.cwd(),
      platform: "node",
      isDev: true
    },
    logger.noopLogger
  );
  const deps = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {
    const pkgName = chunk36EU6KMX_cjs.getPackageName(dep);
    if (pkgName && workspaceMap.has(pkgName)) {
      deps.set(dep, metadata);
    }
  }
  const inputOptions = await chunkBZDTNUHJ_cjs.getInputOptions(
    entryFile,
    {
      dependencies: deps,
      externalDependencies: /* @__PURE__ */ new Set(),
      invalidChunks: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot, projectRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          chunk36EU6KMX_cjs.tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(chunk36EU6KMX_cjs.aliasHono());
    inputOptions.plugins.push(nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await rollup.watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/babel/remove-all-options-server.ts
function removeAllOptionsExceptServer(result, logger) {
  return chunk36EU6KMX_cjs.removeAllOptionsFromMastraExcept(result, "server", logger);
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await chunk36EU6KMX_cjs.extractMastraOption(
    "server",
    entryFile,
    removeAllOptionsExceptServer,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}

exports.createWatcher = createWatcher;
exports.getInputOptions = getInputOptions2;
exports.getServerOptions = getServerOptions;
//# sourceMappingURL=chunk-4PSE6XXT.cjs.map
//# sourceMappingURL=chunk-4PSE6XXT.cjs.map